<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online VipPro</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --square-light: #ecf0f1;
            --square-dark: #95a5a6;
            --highlight: #f1c40f;
            --legal-move: rgba(231, 76, 60, 0.3);
            --check-color: #e74c3c;
        }
        body { font-family: sans-serif; background-color: var(--bg-color); display: flex; flex-direction: column; align-items: center; color: white; margin: 20px; touch-action: none; }
        
        /* Overlay ch·ªçn qu√¢n */
        #role-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .role-box { background: #34495e; padding: 30px; border-radius: 15px; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .game-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }
        
        #board { 
            display: grid; 
            grid-template-columns: repeat(8, 60px); 
            grid-template-rows: repeat(8, 60px); 
            border: 5px solid #34495e; 
            user-select: none; 
            position: relative;
            transition: transform 0.8s cubic-bezier(0.45, 0.05, 0.55, 0.95);
        }

        .square { 
            width: 60px; height: 60px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 40px; position: relative; 
            transition: transform 0.8s cubic-bezier(0.45, 0.05, 0.55, 0.95);
        }
        
        /* Hi·ªáu ·ª©ng thu nh·ªè khi xoay */
        @keyframes shrink-grow {
            0% { scale: 1; }
            50% { scale: 0.35; opacity: 0.7; }
            100% { scale: 1; opacity: 1; }
        }
        .flipping .square { animation: shrink-grow 0.8s ease-in-out; }

        .light { background-color: var(--square-light); }
        .dark { background-color: var(--square-dark); }
        .selected { background-color: var(--highlight) !important; }
        .check { background-color: var(--check-color) !important; }
        .legal-move::after { content: ''; width: 20px; height: 20px; background-color: var(--legal-move); border-radius: 50%; position: absolute; }
        
        .piece { color: black; z-index: 2; cursor: grab; transition: transform 0.2s; }
        .piece.dragging { cursor: grabbing; position: fixed; pointer-events: none; z-index: 1000; transform: translate(-50%, -50%) !important; transition: none !important; scale: 1.5 !important; }

        .event-gif { position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; pointer-events: none; object-fit: cover; }

        .captured-area { height: 40px; display: flex; align-items: center; gap: 2px; font-size: 24px; background: rgba(0,0,0,0.2); padding: 0 10px; border-radius: 4px; margin: 5px 0; min-width: 480px; }
        .info-panel { width: 250px; background: #34495e; padding: 15px; border-radius: 8px; }
        #history { height: 300px; overflow-y: auto; background: #2c3e50; padding: 5px; font-size: 14px; margin-top: 10px; border: 1px solid #444; }
        .status { font-size: 1.2em; margin-bottom: 10px; font-weight: bold; height: 1.5em; }
        
        button { padding: 10px; cursor: pointer; border: none; border-radius: 5px; background: #e67e22; color: white; font-weight: bold; width: 100%; margin-top: 10px; }
        button:hover { background: #d35400; }
        .btn-white { background: #ecf0f1; color: #2c3e50; margin-bottom: 10px; }
        .btn-black { background: #2c3e50; color: #ecf0f1; }
        .last-move { background-color: rgba(241, 196, 15, 0.5) !important; 
}
    </style>
</head>
<body>

    <div id="role-overlay">
        <div class="role-box">
            <h2>CH·ªåN B√äN CH∆†I</h2>
            <button class="btn-white" onclick="selectRole('w')">White</button>
            <button class="btn-black" onclick="selectRole('b')">Black</button>
        </div>
    </div>

    <div class="status" id="status">ƒêang k·∫øt n·ªëi</div>

    <div class="game-container">
        <div class="board-wrapper">
            <div id="captured-black" class="captured-area"></div>
            <div id="board"></div>
            <div id="captured-white" class="captured-area"></div>
        </div>

        <div class="info-panel">
            <strong>History:</strong>
            <div id="history"></div>
            <button onclick="toggleFlip()">Flip Board</button>
            <button style="background:#c0392b" onclick="resetGame()">Reset</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";


        /*const firebaseConfig = {}*/

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const gameRef = ref(db, 'chess_room_1');

        const gifPaths = {
            capture: ['capture1.gif', 'capture2.gif', 'capture3.gif', 'capture4.gif'], 
            check: ['check1.gif', 'check2.gif'],    
            mate: ['mate1.gif']        
        };

        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const historyElement = document.getElementById('history');

        const initialBoard = [
            ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
            ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
            ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e'],
            ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e'],
            ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e'],
            ['e', 'e', 'e', 'e', 'e', 'e', 'e', 'e'],
            ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
            ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
        ];

        const pieceUnicode = { 'bR': '‚ôú', 'bN': '‚ôû', 'bB': '‚ôù', 'bQ': '‚ôõ', 'bK': '‚ôö', 'bP': '‚ôü', 'wR': '‚ôñ', 'wN': '‚ôò', 'wB': '‚ôó', 'wQ': '‚ôï', 'wK': '‚ôî', 'wP': '‚ôô' };

        let boardState = [];
        let turn = 'w';
        let history = [];
        let capturedPieces = { w: [], b: [] };
        let lastMove = null;
        let movedPieces = []; 
        let selectedSquare = null;
        let legalMoves = [];
        let isFlipped = false;
        let myRole = null; // 'w' ho·∫∑c 'b'
        let lastProcessedTimestamp = 0;

        let flashInterval = null;
        const originalTitle = document.title;

        function startTabNotification() {
            // Ch·ªâ th√¥ng b√°o n·∫øu ng∆∞·ªùi d√πng ƒëang ·ªü tab kh√°c
            if (document.hasFocus()) return;
            
            if (flashInterval) clearInterval(flashInterval);
            flashInterval = setInterval(() => {
                document.title = document.title === "üî¥ BRO MOVE!" ? originalTitle : "üî¥ BRO MOVE!";
            }, 1000);
        }

        function stopTabNotification() {
            clearInterval(flashInterval);
            flashInterval = null;
            document.title = originalTitle;
        }

        // T·ª± ƒë·ªông t·∫Øt th√¥ng b√°o khi ng∆∞·ªùi d√πng quay l·∫°i tab
        window.addEventListener('focus', stopTabNotification);

        window.selectRole = function(role) {
            myRole = role;
            document.getElementById('role-overlay').style.display = 'none';
            isFlipped = false;
            if (role === 'b') toggleFlip();
            updateStatus();
        };

        function syncToFirebase(eventData = null) {
            set(gameRef, {
                boardState,
                turn,
                history,
                capturedPieces,
                lastMove,
                movedPieces,
                event: eventData, // {type: 'capture'|'check'|'mate', r, c}
                timestamp: Date.now()
            });
        }

        onValue(gameRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) return;
            if (data.turn === myRole && turn !== data.turn) {
                startTabNotification();
            }
            boardState = data.boardState;
            turn = data.turn;
            history = data.history || [];
            capturedPieces = data.capturedPieces || { w: [], b: [] };
            lastMove = data.lastMove;
            movedPieces = data.movedPieces || [];

            renderBoard();
            updateStatus();

            // X·ª≠ l√Ω hi·ªÉn th·ªã GIF t·ª´ xa
            if (data.event && data.timestamp > lastProcessedTimestamp) {
                showGif(data.event.r, data.event.c, data.event.type);
                lastProcessedTimestamp = data.timestamp;
            }
        });

        function renderBoard() {
            boardElement.innerHTML = '';
            const checkPos = getCheckPos(turn);
            
            // Xoay b√†n c·ªù
            boardElement.style.transform = isFlipped ? "rotate(180deg)" : "rotate(0deg)";

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;

                    if (lastMove) {
                        if ((lastMove.fromR === r && lastMove.fromC === c) || 
                            (lastMove.toR === r && lastMove.toC === c)) {
                            square.classList.add('last-move');
                        }
                    }

                    if (selectedSquare && selectedSquare[0] === r && selectedSquare[1] === c) square.classList.add('selected');
                    if (legalMoves.some(m => m.r === r && m.c === c)) square.classList.add('legal-move');
                    if (checkPos && checkPos.r === r && checkPos.c === c) square.classList.add('check');

                    const piece = boardState[r][c];
                    if (piece !== 'e') {
                        const pieceDiv = document.createElement('div');
                        pieceDiv.className = 'piece';
                        pieceDiv.innerText = pieceUnicode[piece];
                        // Qu√¢n c·ªù xoay ng∆∞·ª£c l·∫°i ƒë·ªÉ lu√¥n ƒë·ª©ng th·∫≥ng
                        pieceDiv.style.transform = isFlipped ? "rotate(180deg)" : "rotate(0deg)";
                        pieceDiv.onmousedown = (e) => startDrag(e, r, c);
                        square.appendChild(pieceDiv);
                    }
                    square.onclick = () => handleSquareClick(r, c);
                    boardElement.appendChild(square);
                }
            }

            document.getElementById('captured-white').innerHTML = (capturedPieces.w || []).map(p => pieceUnicode[p]).join(' ');
            document.getElementById('captured-black').innerHTML = (capturedPieces.b || []).map(p => pieceUnicode[p]).join(' ');
            historyElement.innerHTML = (history || []).map(h => `<div>${h}</div>`).join('');
        }

        function showGif(r, c, type) {
            const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            if (!square) return;
            const paths = gifPaths[type];
            const randomGif = paths[Math.floor(Math.random() * paths.length)];
            const img = document.createElement('img');
            img.src = randomGif + "?t=" + new Date().getTime(); 
            img.className = 'event-gif';
            if (isFlipped) img.style.transform = "rotate(180deg)";
            square.appendChild(img);
            setTimeout(() => img.remove(), 2000);
        }

        function startDrag(e, r, c) {
            if (turn !== myRole || boardState[r][c][0] !== turn) return;
            
            e.stopPropagation();
            selectedSquare = [r, c];
            legalMoves = getLegalMoves(r, c);
            renderBoard();

            const pieceEl = e.target;
            const draggingPiece = pieceEl.cloneNode(true);
            draggingPiece.classList.add('dragging');
            document.body.appendChild(draggingPiece);
            
            const moveAt = (px, py) => {
                draggingPiece.style.left = px + 'px';
                draggingPiece.style.top = py + 'px';
            };
            moveAt(e.clientX, e.clientY);

            const onMouseMove = (ev) => moveAt(ev.clientX, ev.clientY);
            document.addEventListener('mousemove', onMouseMove);

            document.onmouseup = (ev) => {
                document.removeEventListener('mousemove', onMouseMove);
                draggingPiece.remove();
                
                const targetEl = document.elementFromPoint(ev.clientX, ev.clientY);
                const square = targetEl?.closest('.square');
                
                if (square) {
                    const tr = parseInt(square.dataset.row);
                    const tc = parseInt(square.dataset.col);
                    const move = legalMoves.find(m => m.r === tr && m.c === tc);
                    if (move) executeMove(r, c, tr, tc, move);
                }
                document.onmouseup = null;
                if (!square) { selectedSquare = null; legalMoves = []; renderBoard(); }
            };
        }

        function handleSquareClick(r, c) {
            if (turn !== myRole) return;
            const move = legalMoves.find(m => m.r === r && m.c === c);
            if (selectedSquare && move) {
                executeMove(selectedSquare[0], selectedSquare[1], r, c, move);
            } else {
                const piece = boardState[r][c];
                if (piece !== 'e' && piece[0] === turn) {
                    selectedSquare = [r, c];
                    legalMoves = getLegalMoves(r, c);
                } else {
                    selectedSquare = null;
                    legalMoves = [];
                }
                renderBoard();
            }
        }

        function executeMove(fromR, fromC, toR, toC, moveInfo) {
            let piece = boardState[fromR][fromC];
            let captured = boardState[toR][toC];
            let eventData = null;

            if (moveInfo.isEnPassant) {
                captured = boardState[fromR][toC];
                boardState[fromR][toC] = 'e';
            }
            if (moveInfo.isCastling) {
                if (toC === 6) { boardState[toR][5] = boardState[toR][7]; boardState[toR][7] = 'e'; }
                else { boardState[toR][3] = boardState[toR][0]; boardState[toR][0] = 'e'; }
            }
            if (piece[1] === 'P' && (toR === 0 || toR === 7)) {
                piece = piece[0] + (prompt("Promte: Q, R, B, N", "Q") || "Q").toUpperCase();
            }

            if (captured !== 'e') {
                capturedPieces[captured[0]].push(captured);
                eventData = { type: 'capture', r: toR, c: toC };
            }

            boardState[toR][toC] = piece;
            boardState[fromR][fromC] = 'e';
            movedPieces.push(`${fromR},${fromC}`);
            lastMove = { piece, fromR, fromC, toR, toC };
            history.unshift(`${pieceUnicode[piece]} (${fromR},${fromC})‚Üí(${toR},${toC})`);
            
            turn = turn === 'w' ? 'b' : 'w';
            
            // Ki·ªÉm tra chi·∫øu/chi·∫øu h·∫øt ƒë·ªÉ t·∫°o event GIF
            const kingPos = getCheckPos(turn);
            if (kingPos) {
                const isMate = isCheckmate(turn);
                eventData = { type: isMate ? 'mate' : 'check', r: kingPos.r, c: kingPos.c };
            }

            selectedSquare = null;
            legalMoves = [];
            syncToFirebase(eventData);
        }

        // --- LOGIC C·ªú VUA C∆† B·∫¢N ---
        function getCheckPos(color) {
            let kingPos = null;
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) if(boardState[r][c] === color + 'K') kingPos = {r, c};
            }
            if(!kingPos) return null;
            return isSquareAttacked(kingPos.r, kingPos.c, color === 'w' ? 'b' : 'w') ? kingPos : null;
        }

        function isSquareAttacked(r, c, attackerColor) {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = boardState[i][j];
                    if (piece !== 'e' && piece[0] === attackerColor) {
                        if (getPseudoLegalMoves(i, j, true).some(m => m.r === r && m.c === c)) return true;
                    }
                }
            }
            return false;
        }

        function getPseudoLegalMoves(r, c, ignoreCastling = false) {
            const piece = boardState[r][c];
            if (piece === 'e') return [];
            const color = piece[0], type = piece[1], moves = [];
            const dirs = {
                'R': [[0,1],[0,-1],[1,0],[-1,0]], 'B': [[1,1],[1,-1],[-1,1],[-1,-1]],
                'Q': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
                'N': [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
                'K': [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
            };
            if (type === 'P') {
                const d = color === 'w' ? -1 : 1;
                if (boardState[r+d] && boardState[r+d][c] === 'e') {
                    moves.push({r: r+d, c: c});
                    if (((color === 'w' && r === 6) || (color === 'b' && r === 1)) && boardState[r+2*d][c] === 'e') moves.push({r: r+2*d, c: c});
                }
                [-1, 1].forEach(dc => {
                    const target = boardState[r+d] ? boardState[r+d][c+dc] : null;
                    if (target && target !== 'e' && target[0] !== color) moves.push({r: r+d, c: c+dc});
                    if (target === 'e' && lastMove && lastMove.piece[1] === 'P' && lastMove.toR === r && lastMove.toC === c+dc && Math.abs(lastMove.fromR - lastMove.toR) === 2) moves.push({r: r+d, c: c+dc, isEnPassant: true});
                });
            } else if (dirs[type]) {
                for (let [dr, dc] of dirs[type]) {
                    let nr = r+dr, nc = c+dc;
                    while (nr>=0 && nr<8 && nc>=0 && nc<8) {
                        const t = boardState[nr][nc];
                        if (t === 'e') { moves.push({r: nr, c: nc}); if (type==='N'||type==='K') break; }
                        else { if (t[0]!==color) moves.push({r: nr, c: nc}); break; }
                        nr+=dr; nc+=dc;
                    }
                }
                if (type === 'K' && !ignoreCastling && !movedPieces.includes(`${r},${c}`) && !getCheckPos(color)) {
                    if (!movedPieces.includes(`${r},7`) && boardState[r][5] === 'e' && boardState[r][6] === 'e') moves.push({r, c: 6, isCastling: true});
                    if (!movedPieces.includes(`${r},0`) && boardState[r][1] === 'e' && boardState[r][2] === 'e' && boardState[r][3] === 'e') moves.push({r, c: 2, isCastling: true});
                }
            }
            return moves;
        }

        function getLegalMoves(r, c) {
            return getPseudoLegalMoves(r, c).filter(m => {
                const oldTo = boardState[m.r][m.c], oldFrom = boardState[r][c];
                boardState[m.r][m.c] = oldFrom; boardState[r][c] = 'e';
                const check = getCheckPos(oldFrom[0]);
                boardState[r][c] = oldFrom; boardState[m.r][m.c] = oldTo;
                return !check;
            });
        }

        function isCheckmate(color) {
            if (!getCheckPos(color)) return false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (boardState[r][c] !== 'e' && boardState[r][c][0] === color) {
                        if (getLegalMoves(r, c).length > 0) return false;
                    }
                }
            }
            return true;
        }

        function isStalemate(color) {
            if (getCheckPos(color)) return false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (boardState[r][c] !== 'e' && boardState[r][c][0] === color) {
                        if (getLegalMoves(r, c).length > 0) return false;
                    }
                }
            }
            return true;
        }

        function updateStatus() {
            if (!myRole) return;
            const turnText = turn === 'w' ? "White" : "Black";
            const myTurn = turn === myRole ? " (Yours)" : " (Opps)";
            if (isCheckmate(turn)) {
                statusElement.innerText = `CHECK MATE! ${turn === 'w' ? 'BLACK' : 'WHITE'} WINS`;
                statusElement.style.color = "#98db34";
            } else if (isStalemate(turn)) {
                statusElement.innerText = `STALEMATE`;
                statusElement.style.color = "#3498db"; 
            } else {
                statusElement.innerText = `Turn: ${turnText}${myTurn}`;
                statusElement.style.color = turn === myRole ? "#f1c40f" : "white";
            }
        }

        window.resetGame = function() {
            if (confirm("New game?")) {
                boardState = JSON.parse(JSON.stringify(initialBoard));
                turn = 'w'; history = []; capturedPieces = { w: [], b: [] }; lastMove = null; movedPieces = [];
                syncToFirebase({type: 'reset'});
            }
        };

        window.toggleFlip = function() {
            isFlipped = !isFlipped;
            boardElement.classList.add('flipping');
            renderBoard();
            setTimeout(() => boardElement.classList.remove('flipping'), 800);
        };
    </script>
</body>
</html>
